// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/cli, DO NOT EDIT.

package nestedaction

import (
    "github.com/smartcontractkit/chainlink-common/pkg/capabilities"
    "github.com/smartcontractkit/chainlink-common/pkg/workflows"
)



func (cfg ActionConfig) New(w *workflows.WorkflowSpecFactory,ref string, input ActionInput)ActionOutputsCap {
    
    def := workflows.StepDefinition{
       ID: "nested-test-action@1.0.0",Ref: ref,
       Inputs: input.ToSteps(),
       Config: map[string]any{
           "details": cfg.Details,
       },
       CapabilityType: capabilities.CapabilityTypeAction,
   }


    step := workflows.Step[ActionOutputs]{Definition: def}
    return ActionOutputsCapFromStep(w, step)
}


type ActionOutputsCap interface {
    workflows.CapDefinition[ActionOutputs]
    Results() ActionOutputsResultsCap
    private()
}


// ActionOutputsCapFromStep should only be called from generated code to assure type safety
func ActionOutputsCapFromStep(w *workflows.WorkflowSpecFactory, step workflows.Step[ActionOutputs]) ActionOutputsCap {
    raw :=  step.AddTo(w)
    return &actionOutputs{CapDefinition: raw}
}


type actionOutputs struct {
    workflows.CapDefinition[ActionOutputs]
}

func (*actionOutputs) private() {}
func (c *actionOutputs) Results() ActionOutputsResultsCap {
     return &actionOutputsResults{ CapDefinition: workflows.AccessField[ActionOutputs, ActionOutputsResults](c.CapDefinition, "Results")}
}

func NewActionOutputsFromFields(
                                                                        results ActionOutputsResultsCap,) ActionOutputsCap {
    return &simpleActionOutputs{
        CapDefinition: workflows.ComponentCapDefinition[ActionOutputs]{
        "results": results.Ref(),
        },
        results: results,
    }
}

type simpleActionOutputs struct {
    workflows.CapDefinition[ActionOutputs]
    results ActionOutputsResultsCap
}
func (c *simpleActionOutputs) Results() ActionOutputsResultsCap {
    return c.results
}

func (c *simpleActionOutputs) private() {}


type ActionOutputsResultsCap interface {
    workflows.CapDefinition[ActionOutputsResults]
    AdaptedThing() workflows.CapDefinition[string]
    private()
}


// ActionOutputsResultsCapFromStep should only be called from generated code to assure type safety
func ActionOutputsResultsCapFromStep(w *workflows.WorkflowSpecFactory, step workflows.Step[ActionOutputsResults]) ActionOutputsResultsCap {
    raw :=  step.AddTo(w)
    return &actionOutputsResults{CapDefinition: raw}
}


type actionOutputsResults struct {
    workflows.CapDefinition[ActionOutputsResults]
}

func (*actionOutputsResults) private() {}
func (c *actionOutputsResults) AdaptedThing() workflows.CapDefinition[string] {
    return workflows.AccessField[ActionOutputsResults, string](c.CapDefinition, "AdaptedThing")
}

func NewActionOutputsResultsFromFields(
                                                                        adaptedThing workflows.CapDefinition[string],) ActionOutputsResultsCap {
    return &simpleActionOutputsResults{
        CapDefinition: workflows.ComponentCapDefinition[ActionOutputsResults]{
        "adaptedThing": adaptedThing.Ref(),
        },
        adaptedThing: adaptedThing,
    }
}

type simpleActionOutputsResults struct {
    workflows.CapDefinition[ActionOutputsResults]
    adaptedThing workflows.CapDefinition[string]
}
func (c *simpleActionOutputsResults) AdaptedThing() workflows.CapDefinition[string] {
    return c.adaptedThing
}

func (c *simpleActionOutputsResults) private() {}


type ActionInput struct {
    Metadata workflows.CapDefinition[ActionInputsMetadata]
}

func (input ActionInput) ToSteps() workflows.StepInputs {
    return workflows.StepInputs{
       Mapping: map[string]any{
        "metadata": input.Metadata.Ref(),
       },
   }
}