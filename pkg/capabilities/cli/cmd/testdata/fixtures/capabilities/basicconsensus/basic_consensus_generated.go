// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/cli, DO NOT EDIT.

package basicconsensus

import (
	"encoding/json"
	"fmt"
)

// Basic Test Consensus
type Consensus struct {
	// Config corresponds to the JSON schema field "config".
	Config ConsensusConfig `json:"config" yaml:"config" mapstructure:"config"`

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs *ConsensusInputs `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// NOTE, OCR3 is the consensus we support that has output as signed report, this
	// is simply testing that generation is right
	Outputs *ConsensusOutputs `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`
}

type ConsensusConfig struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The interval in seconds after which a new trigger event is generated.
	Number uint64 `json:"number" yaml:"number" mapstructure:"number"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ConsensusConfig: required")
	}
	if _, ok := raw["number"]; raw != nil && !ok {
		return fmt.Errorf("field number in ConsensusConfig: required")
	}
	type Plain ConsensusConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1 > plain.Number {
		return fmt.Errorf("field %s: must be >= %v", "number", 1)
	}
	*j = ConsensusConfig(plain)
	return nil
}

type ConsensusInputs struct {
	// InputThing corresponds to the JSON schema field "input_thing".
	InputThing bool `json:"input_thing" yaml:"input_thing" mapstructure:"input_thing"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusInputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["input_thing"]; raw != nil && !ok {
		return fmt.Errorf("field input_thing in ConsensusInputs: required")
	}
	type Plain ConsensusInputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConsensusInputs(plain)
	return nil
}

// NOTE, OCR3 is the consensus we support that has output as signed report, this is
// simply testing that generation is right
type ConsensusOutputs struct {
	// Consensus corresponds to the JSON schema field "consensus".
	Consensus []string `json:"consensus" yaml:"consensus" mapstructure:"consensus"`

	// Sigs corresponds to the JSON schema field "sigs".
	Sigs []string `json:"sigs" yaml:"sigs" mapstructure:"sigs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusOutputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["consensus"]; raw != nil && !ok {
		return fmt.Errorf("field consensus in ConsensusOutputs: required")
	}
	if _, ok := raw["sigs"]; raw != nil && !ok {
		return fmt.Errorf("field sigs in ConsensusOutputs: required")
	}
	type Plain ConsensusOutputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConsensusOutputs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Consensus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in Consensus: required")
	}
	type Plain Consensus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Consensus(plain)
	return nil
}
