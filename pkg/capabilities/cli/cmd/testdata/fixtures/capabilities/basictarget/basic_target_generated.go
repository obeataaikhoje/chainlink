// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/cli, DO NOT EDIT.

package basictarget

import "encoding/json"
import "fmt"

// Basic Test Target
type Target struct {
	// NOTE that real targets would likely take consensus as input, this is only for
	// testing
	Config TargetConfig `json:"config" yaml:"config" mapstructure:"config"`

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs *TargetInputs `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`
}

// NOTE that real targets would likely take consensus as input, this is only for
// testing
type TargetConfig struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The interval in seconds after which a new trigger event is generated.
	Number int `json:"number" yaml:"number" mapstructure:"number"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in TargetConfig: required")
	}
	if _, ok := raw["number"]; raw != nil && !ok {
		return fmt.Errorf("field number in TargetConfig: required")
	}
	type Plain TargetConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1 > plain.Number {
		return fmt.Errorf("field %s: must be >= %v", "number", 1)
	}
	*j = TargetConfig(plain)
	return nil
}

type TargetInputs struct {
	// CoolInput corresponds to the JSON schema field "cool_input".
	CoolInput *string `json:"cool_input,omitempty" yaml:"cool_input,omitempty" mapstructure:"cool_input,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Target) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in Target: required")
	}
	type Plain Target
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Target(plain)
	return nil
}
