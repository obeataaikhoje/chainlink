// Code generated by pkg/capabilities/cli, DO NOT EDIT.

package {{.Package|PkgToCapPkg}}

import (
    "github.com/smartcontractkit/chainlink-common/pkg/capabilities"
    "github.com/smartcontractkit/chainlink-common/pkg/workflows"

    "{{.FullPackage}}"

    {{- range .ExtraImports }}
    {{.}}
    {{- end }}
)

func New{{.BaseName}}(w *workflows.Workflow, {{- if not .Id }}id string,{{- end }} {{- if and (ne .CapabilityType.String "target") (ne .CapabilityType.String "trigger")}}ref string,{{- end }}{{- if .Input }} input {{InputAfterCapability}}, {{- end }} cfg {{.Package}}.{{.Config.Name}}) {{- if ne .CapabilityType.String "target"}}{{.BaseName}}{{- end }} {
    {{- if eq .CapabilityType.String "trigger" }} ref := "trigger" {{- end }}
    def := workflows.StepDefinition{
       ID: {{- if .Id }} "{{.Id}}" {{- else }} id {{- end }},
       {{- if ne .CapabilityType.String "target"}}Ref: ref, {{- end }}
       Inputs: workflows.StepInputs{
{{- if .Input }}
           Mapping: map[string]any{
   {{- range $fieldName, $type := .Input.Outputs }}
               "{{$type.ConfigName}}": input.{{$fieldName}}.Ref(),
   {{- end }}
           },
{{- end }}
       },
       Config: map[string]any{
{{- range $fieldName, $type := .Config.Outputs }}
           "{{$type.ConfigName}}": cfg.{{$fieldName}},
{{- end }}
       },
       CapabilityType: capabilities.CapabilityType{{.CapabilityType.String|Capitalize}},
   }
    step := workflows.Step[{{- if eq .CapabilityType.String "target"}}struct{}{{- else }}{{.RootType.Name|PkgIfNeeded}} {{- end}}]{Definition: def}
    {{if ne .CapabilityType.String "target"}} raw := {{- end }} workflows.AddStep(w, step)
    return {{- if ne .CapabilityType.String "target"}} &{{.BaseName|LowerFirst}}{CapDefinition: raw} {{- end }}
}

{{ range $key, $value := .Types }}
{{- if .Outputs }}
type {{$key|ConvertToBaseIfFirstOutput}} interface {
    workflows.CapDefinition[{{ $key | PkgIfNeeded }}]
    {{- range $fieldName, $type := .Outputs }}
        {{- if $type.IsPrimitive }}
    {{$fieldName}}() workflows.CapDefinition[{{Repeat "[]" $type.NumSlice}}{{ $type.Type }}]
        {{- else }}
    {{$fieldName}}() {{Repeat "[]" $type.NumSlice}}{{ $type.Type }}
        {{- end }}
    {{- end }}
    private()
}

type {{$key|ConvertToBaseIfFirstOutput|LowerFirst}} struct {
    workflows.CapDefinition[{{ $key | PkgIfNeeded }}]
}


func (*{{$key|ConvertToBaseIfFirstOutput|LowerFirst}}) private() {}

    {{- range $fieldName, $type := .Outputs }}
        {{- if or $type.IsPrimitive }}
func (c *{{$key|ConvertToBaseIfFirstOutput|LowerFirst}}) {{$fieldName}}() workflows.CapDefinition[{{Repeat "[]" $type.NumSlice}}{{ $type.Type | PkgIfNeeded }}] {
    return workflows.AccessField[{{$value.Name | PkgIfNeeded}}, {{Repeat "[]" $type.NumSlice}}{{$type.Type | PkgIfNeeded}}](c.CapDefinition, "{{$fieldName}}")
}
        {{- else }}
func (c *{{$key|ConvertToBaseIfFirstOutput|LowerFirst}}) {{$fieldName}}() {{ $type.Type }} {
           {{- if $type.Type|HasOutputs }}
     return &{{ $type.Type | LowerFirst }}{ CapDefinition: workflows.AccessField[{{$value.Name | PkgIfNeeded}}, {{$type.Type | PkgIfNeeded}}](c.CapDefinition, "{{$fieldName}}")}
           {{- else }}
     return {{ $type.Type }}(workflows.AccessField[{{$value.Name | PkgIfNeeded}}, {{$type.Type | PkgIfNeeded}}](c.CapDefinition, "{{$fieldName}}"))
           {{- end }}
}
        {{- end }}
    {{- end }}

func New{{$key|ConvertToBaseIfFirstOutput}}FromFields({{- range $fieldName, $type := .Outputs }}
                                                                            {{- if $type.IsPrimitive }}
                                                                        {{$fieldName|LowerFirst}} workflows.CapDefinition[{{Repeat "[]" $type.NumSlice}}{{ $type.Type }}],
                                                                            {{- else }}
                                                                        {{$fieldName|LowerFirst}} {{Repeat "[]" $type.NumSlice}}{{ $type.Type }},
                                                                            {{- end }}                                                                        {{- end }}) {{$key|ConvertToBaseIfFirstOutput}} {
    return &simple{{$key|ConvertToBaseIfFirstOutput}}{
        CapDefinition: workflows.ComponentCapDefinition[{{$value.Name|PkgIfNeeded}}]{ {{- range $fieldName, $type := .Outputs }}
        "{{$fieldName|LowerFirst}}": {{$fieldName|LowerFirst}}.Ref(),
        {{- end }}
        },
        {{- range $fieldName, $type := .Outputs }}
        {{$fieldName|LowerFirst}}: {{$fieldName|LowerFirst}},
        {{- end }}
    }
}

type simple{{$key|ConvertToBaseIfFirstOutput}} struct {
    workflows.CapDefinition[{{ $key | PkgIfNeeded }}]
    {{- range $fieldName, $type := .Outputs }}
        {{- if $type.IsPrimitive }}
    {{$fieldName|LowerFirst}} workflows.CapDefinition[{{Repeat "[]" $type.NumSlice}}{{ $type.Type | PkgIfNeeded }}]
        {{- else }}
    {{$fieldName|LowerFirst}} {{Repeat "[]" $type.NumSlice}}{{ $type.Type }}
        {{- end }}
    {{- end }}
}

 {{- range $fieldName, $type := .Outputs }}
        {{- if $type.IsPrimitive }}
func (c *simple{{$key|ConvertToBaseIfFirstOutput}}) {{$fieldName}}() workflows.CapDefinition[{{Repeat "[]" $type.NumSlice}}{{ $type.Type }}] {
        {{- else }}
func (c *simple{{$key|ConvertToBaseIfFirstOutput}}) {{$fieldName}}() {{ $type.Type }} {
        {{- end }}
    return c.{{$fieldName|LowerFirst}}
}
    {{- end }}

func (c *simple{{$key|ConvertToBaseIfFirstOutput}}) private() {}
{{- else }}
type {{$key|ConvertToBaseIfFirstOutput}} workflows.CapDefinition[{{ $key | PkgIfNeeded }}]
{{- end }}

{{ end }}

{{- if .Input }}
type {{InputAfterCapability}} struct {
{{- range $fieldName, $type := .Input.Outputs }}
    {{$fieldName}} workflows.CapDefinition[{{Repeat "[]" $type.NumSlice}}{{ $type.Type }}]
{{- end }}
}
{{- end }}