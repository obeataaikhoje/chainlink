// Code generated by pkg/capabilities/cli, DO NOT EDIT.

package ocr3

import "encoding/json"
import "fmt"
import streams "github.com/smartcontractkit/chainlink-common/pkg/capabilities/triggers/streams"
import "reflect"

// OCR3 consensus exposed as a capability.
type Ocr3Consensus struct {
	// Config corresponds to the JSON schema field "config".
	Config Ocr3ConsensusConfig

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs Ocr3ConsensusInputs

	// Outputs corresponds to the JSON schema field "outputs".
	Outputs SignedReport
}

type Ocr3ConsensusConfig struct {
	// AggregationConfig corresponds to the JSON schema field "aggregationConfig".
	AggregationConfig []Ocr3ConsensusConfigAggregationConfigElem

	// AggregationMethod corresponds to the JSON schema field "aggregationMethod".
	AggregationMethod Ocr3ConsensusConfigAggregationMethod

	// Encoder corresponds to the JSON schema field "encoder".
	Encoder Ocr3ConsensusConfigEncoder

	// EncoderConfig corresponds to the JSON schema field "encoderConfig".
	EncoderConfig Ocr3ConsensusConfigEncoderConfig

	// ReportId corresponds to the JSON schema field "reportId".
	ReportId string
}

type Ocr3ConsensusConfigAggregationConfigElem struct {
	// The deviation that is required to generate a new report. Expressed as a
	// percentage. For example, 0.01 is 1% deviation.
	Deviation float64

	// The ID of the data feed.
	FeedId string

	// The interval in seconds after which a new report is generated, regardless of
	// whether any deviations have occurred. New reports reset the timer.
	Heartbeat int
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3ConsensusConfigAggregationConfigElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deviation"]; raw != nil && !ok {
		return fmt.Errorf("field deviation in Ocr3ConsensusConfigAggregationConfigElem: required")
	}
	if _, ok := raw["feedId"]; raw != nil && !ok {
		return fmt.Errorf("field feedId in Ocr3ConsensusConfigAggregationConfigElem: required")
	}
	if _, ok := raw["heartbeat"]; raw != nil && !ok {
		return fmt.Errorf("field heartbeat in Ocr3ConsensusConfigAggregationConfigElem: required")
	}
	type Plain Ocr3ConsensusConfigAggregationConfigElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ocr3ConsensusConfigAggregationConfigElem(plain)
	return nil
}

type Ocr3ConsensusConfigAggregationMethod string

const Ocr3ConsensusConfigAggregationMethodDataFeeds Ocr3ConsensusConfigAggregationMethod = "data_feeds"

var enumValues_Ocr3ConsensusConfigAggregationMethod = []interface{}{
	"data_feeds",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3ConsensusConfigAggregationMethod) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Ocr3ConsensusConfigAggregationMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Ocr3ConsensusConfigAggregationMethod, v)
	}
	*j = Ocr3ConsensusConfigAggregationMethod(v)
	return nil
}

type Ocr3ConsensusConfigEncoder string

type Ocr3ConsensusConfigEncoderConfig struct {
	// The ABI for report encoding.
	Abi string
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3ConsensusConfigEncoderConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["abi"]; raw != nil && !ok {
		return fmt.Errorf("field abi in Ocr3ConsensusConfigEncoderConfig: required")
	}
	type Plain Ocr3ConsensusConfigEncoderConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ocr3ConsensusConfigEncoderConfig(plain)
	return nil
}

const Ocr3ConsensusConfigEncoderEVM Ocr3ConsensusConfigEncoder = "EVM"

var enumValues_Ocr3ConsensusConfigEncoder = []interface{}{
	"EVM",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3ConsensusConfigEncoder) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Ocr3ConsensusConfigEncoder {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Ocr3ConsensusConfigEncoder, v)
	}
	*j = Ocr3ConsensusConfigEncoder(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3ConsensusConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aggregationConfig"]; raw != nil && !ok {
		return fmt.Errorf("field aggregationConfig in Ocr3ConsensusConfig: required")
	}
	if _, ok := raw["aggregationMethod"]; raw != nil && !ok {
		return fmt.Errorf("field aggregationMethod in Ocr3ConsensusConfig: required")
	}
	if _, ok := raw["encoder"]; raw != nil && !ok {
		return fmt.Errorf("field encoder in Ocr3ConsensusConfig: required")
	}
	if _, ok := raw["encoderConfig"]; raw != nil && !ok {
		return fmt.Errorf("field encoderConfig in Ocr3ConsensusConfig: required")
	}
	if _, ok := raw["reportId"]; raw != nil && !ok {
		return fmt.Errorf("field reportId in Ocr3ConsensusConfig: required")
	}
	type Plain Ocr3ConsensusConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ocr3ConsensusConfig(plain)
	return nil
}

type Ocr3ConsensusInputs struct {
	// Observations corresponds to the JSON schema field "observations".
	Observations []streams.Feed
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3ConsensusInputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["observations"]; raw != nil && !ok {
		return fmt.Errorf("field observations in Ocr3ConsensusInputs: required")
	}
	type Plain Ocr3ConsensusInputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ocr3ConsensusInputs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ocr3Consensus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in Ocr3Consensus: required")
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in Ocr3Consensus: required")
	}
	if _, ok := raw["outputs"]; raw != nil && !ok {
		return fmt.Errorf("field outputs in Ocr3Consensus: required")
	}
	type Plain Ocr3Consensus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ocr3Consensus(plain)
	return nil
}

type SignedReport struct {
	// Err corresponds to the JSON schema field "Err".
	Err bool

	// Value corresponds to the JSON schema field "Value".
	Value SignedReportValue

	// WorkflowExecutionID corresponds to the JSON schema field "WorkflowExecutionID".
	WorkflowExecutionID string
}

type SignedReportValue struct {
	// Underlying corresponds to the JSON schema field "Underlying".
	Underlying SignedReportValueUnderlying
}

type SignedReportValueUnderlying map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedReportValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Underlying"]; raw != nil && !ok {
		return fmt.Errorf("field Underlying in SignedReportValue: required")
	}
	type Plain SignedReportValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SignedReportValue(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedReport) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Err"]; raw != nil && !ok {
		return fmt.Errorf("field Err in SignedReport: required")
	}
	if _, ok := raw["Value"]; raw != nil && !ok {
		return fmt.Errorf("field Value in SignedReport: required")
	}
	if _, ok := raw["WorkflowExecutionID"]; raw != nil && !ok {
		return fmt.Errorf("field WorkflowExecutionID in SignedReport: required")
	}
	type Plain SignedReport
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SignedReport(plain)
	return nil
}
