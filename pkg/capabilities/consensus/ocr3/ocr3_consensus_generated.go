// Code generated by pkg/capabilities/cli, DO NOT EDIT.

package ocr3

import "encoding/json"
import "fmt"
import streams "github.com/smartcontractkit/chainlink-common/pkg/capabilities/triggers/streams"
import "reflect"

// OCR3 consensus exposed as a capability.
type Consensus struct {
	// Config corresponds to the JSON schema field "config".
	Config ConsensusConfig

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs ConsensusInputs

	// Outputs corresponds to the JSON schema field "outputs".
	Outputs SignedReport
}

type ConsensusConfig struct {
	// AggregationConfig corresponds to the JSON schema field "aggregationConfig".
	AggregationConfig []ConsensusConfigAggregationConfigElem

	// AggregationMethod corresponds to the JSON schema field "aggregationMethod".
	AggregationMethod ConsensusConfigAggregationMethod

	// Encoder corresponds to the JSON schema field "encoder".
	Encoder ConsensusConfigEncoder

	// EncoderConfig corresponds to the JSON schema field "encoderConfig".
	EncoderConfig ConsensusConfigEncoderConfig

	// ReportId corresponds to the JSON schema field "reportId".
	ReportId string
}

type ConsensusConfigAggregationConfigElem struct {
	// The deviation that is required to generate a new report. Expressed as a
	// percentage. For example, 0.01 is 1% deviation.
	Deviation float64

	// FeedId corresponds to the JSON schema field "feedId".
	FeedId streams.FeedId

	// The interval in seconds after which a new report is generated, regardless of
	// whether any deviations have occurred. New reports reset the timer.
	Heartbeat int
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusConfigAggregationConfigElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deviation"]; raw != nil && !ok {
		return fmt.Errorf("field deviation in ConsensusConfigAggregationConfigElem: required")
	}
	if _, ok := raw["feedId"]; raw != nil && !ok {
		return fmt.Errorf("field feedId in ConsensusConfigAggregationConfigElem: required")
	}
	if _, ok := raw["heartbeat"]; raw != nil && !ok {
		return fmt.Errorf("field heartbeat in ConsensusConfigAggregationConfigElem: required")
	}
	type Plain ConsensusConfigAggregationConfigElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConsensusConfigAggregationConfigElem(plain)
	return nil
}

type ConsensusConfigAggregationMethod string

const ConsensusConfigAggregationMethodDataFeeds ConsensusConfigAggregationMethod = "data_feeds"

var enumValues_ConsensusConfigAggregationMethod = []interface{}{
	"data_feeds",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusConfigAggregationMethod) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConsensusConfigAggregationMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConsensusConfigAggregationMethod, v)
	}
	*j = ConsensusConfigAggregationMethod(v)
	return nil
}

type ConsensusConfigEncoder string

type ConsensusConfigEncoderConfig struct {
	// The ABI for report encoding.
	Abi string
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusConfigEncoderConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["abi"]; raw != nil && !ok {
		return fmt.Errorf("field abi in ConsensusConfigEncoderConfig: required")
	}
	type Plain ConsensusConfigEncoderConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConsensusConfigEncoderConfig(plain)
	return nil
}

const ConsensusConfigEncoderEVM ConsensusConfigEncoder = "EVM"

var enumValues_ConsensusConfigEncoder = []interface{}{
	"EVM",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusConfigEncoder) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConsensusConfigEncoder {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConsensusConfigEncoder, v)
	}
	*j = ConsensusConfigEncoder(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aggregationConfig"]; raw != nil && !ok {
		return fmt.Errorf("field aggregationConfig in ConsensusConfig: required")
	}
	if _, ok := raw["aggregationMethod"]; raw != nil && !ok {
		return fmt.Errorf("field aggregationMethod in ConsensusConfig: required")
	}
	if _, ok := raw["encoder"]; raw != nil && !ok {
		return fmt.Errorf("field encoder in ConsensusConfig: required")
	}
	if _, ok := raw["encoderConfig"]; raw != nil && !ok {
		return fmt.Errorf("field encoderConfig in ConsensusConfig: required")
	}
	if _, ok := raw["reportId"]; raw != nil && !ok {
		return fmt.Errorf("field reportId in ConsensusConfig: required")
	}
	type Plain ConsensusConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConsensusConfig(plain)
	return nil
}

type ConsensusInputs struct {
	// Observations corresponds to the JSON schema field "observations".
	Observations []streams.Feed
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusInputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["observations"]; raw != nil && !ok {
		return fmt.Errorf("field observations in ConsensusInputs: required")
	}
	type Plain ConsensusInputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConsensusInputs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Consensus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in Consensus: required")
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in Consensus: required")
	}
	if _, ok := raw["outputs"]; raw != nil && !ok {
		return fmt.Errorf("field outputs in Consensus: required")
	}
	type Plain Consensus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Consensus(plain)
	return nil
}

type SignedReport struct {
	// Err corresponds to the JSON schema field "Err".
	Err bool

	// Value corresponds to the JSON schema field "Value".
	Value SignedReportValue

	// WorkflowExecutionID corresponds to the JSON schema field "WorkflowExecutionID".
	WorkflowExecutionID string
}

type SignedReportValue struct {
	// Underlying corresponds to the JSON schema field "Underlying".
	Underlying SignedReportValueUnderlying
}

type SignedReportValueUnderlying map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedReportValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Underlying"]; raw != nil && !ok {
		return fmt.Errorf("field Underlying in SignedReportValue: required")
	}
	type Plain SignedReportValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SignedReportValue(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedReport) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Err"]; raw != nil && !ok {
		return fmt.Errorf("field Err in SignedReport: required")
	}
	if _, ok := raw["Value"]; raw != nil && !ok {
		return fmt.Errorf("field Value in SignedReport: required")
	}
	if _, ok := raw["WorkflowExecutionID"]; raw != nil && !ok {
		return fmt.Errorf("field WorkflowExecutionID in SignedReport: required")
	}
	type Plain SignedReport
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SignedReport(plain)
	return nil
}
