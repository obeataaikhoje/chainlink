// Code generated by pkg/capabilities/cli, DO NOT EDIT.

package chain_writer

import "encoding/json"
import "fmt"
import ocr3 "github.com/smartcontractkit/chainlink-common/pkg/capabilities/consensus/ocr3"
import "reflect"

// Writes to evm chain for now...
type ChainwriterTarget struct {
	// Config corresponds to the JSON schema field "config".
	Config ChainwriterTargetConfig

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs ChainwriterTargetInputs
}

type ChainwriterTargetConfig struct {
	// The address in the format 0x followed by 40 characters.
	Address string

	// The delta stage which must be a number followed by a time symbol (s for
	// seconds, m for minutes, h for hours, d for days).
	DeltaStage string

	// The schedule which must be the string 'oneAtATime'.
	Schedule ChainwriterTargetConfigSchedule
}

type ChainwriterTargetConfigSchedule string

const ChainwriterTargetConfigScheduleOneAtATime ChainwriterTargetConfigSchedule = "oneAtATime"

var enumValues_ChainwriterTargetConfigSchedule = []interface{}{
	"oneAtATime",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTargetConfigSchedule) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChainwriterTargetConfigSchedule {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChainwriterTargetConfigSchedule, v)
	}
	*j = ChainwriterTargetConfigSchedule(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTargetConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in ChainwriterTargetConfig: required")
	}
	if _, ok := raw["deltaStage"]; raw != nil && !ok {
		return fmt.Errorf("field deltaStage in ChainwriterTargetConfig: required")
	}
	if _, ok := raw["schedule"]; raw != nil && !ok {
		return fmt.Errorf("field schedule in ChainwriterTargetConfig: required")
	}
	type Plain ChainwriterTargetConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChainwriterTargetConfig(plain)
	return nil
}

type ChainwriterTargetInputs struct {
	// SignedReport corresponds to the JSON schema field "signed_report".
	SignedReport ocr3.SignedReport
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTargetInputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["signed_report"]; raw != nil && !ok {
		return fmt.Errorf("field signed_report in ChainwriterTargetInputs: required")
	}
	type Plain ChainwriterTargetInputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChainwriterTargetInputs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTarget) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in ChainwriterTarget: required")
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in ChainwriterTarget: required")
	}
	type Plain ChainwriterTarget
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChainwriterTarget(plain)
	return nil
}
