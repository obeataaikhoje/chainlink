// Code generated by pkg/capabilities/cli, DO NOT EDIT.

package chainwriter

import "encoding/json"
import "fmt"

// Writes to evm chain for now...
type ChainwriterTarget struct {
	// Config corresponds to the JSON schema field "config".
	Config ChainwriterTargetConfig

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs ChainwriterTargetInputs
}

type ChainwriterTargetConfig struct {
	// Address corresponds to the JSON schema field "address".
	Address string
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTargetConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in ChainwriterTargetConfig: required")
	}
	type Plain ChainwriterTargetConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Address) < 42 {
		return fmt.Errorf("field %s length: must be >= %d", "address", 42)
	}
	if len(plain.Address) > 42 {
		return fmt.Errorf("field %s length: must be <= %d", "address", 42)
	}
	*j = ChainwriterTargetConfig(plain)
	return nil
}

type ChainwriterTargetInputs struct {
	// Err corresponds to the JSON schema field "Err".
	Err interface{}

	// Value corresponds to the JSON schema field "Value".
	Value ChainwriterTargetInputsValue

	// WorkflowExecutionID corresponds to the JSON schema field "WorkflowExecutionID".
	WorkflowExecutionID string
}

type ChainwriterTargetInputsValue struct {
	// Underlying corresponds to the JSON schema field "Underlying".
	Underlying ChainwriterTargetInputsValueUnderlying
}

type ChainwriterTargetInputsValueUnderlying map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTargetInputsValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Underlying"]; raw != nil && !ok {
		return fmt.Errorf("field Underlying in ChainwriterTargetInputsValue: required")
	}
	type Plain ChainwriterTargetInputsValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChainwriterTargetInputsValue(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTargetInputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Err"]; raw != nil && !ok {
		return fmt.Errorf("field Err in ChainwriterTargetInputs: required")
	}
	if _, ok := raw["Value"]; raw != nil && !ok {
		return fmt.Errorf("field Value in ChainwriterTargetInputs: required")
	}
	if _, ok := raw["WorkflowExecutionID"]; raw != nil && !ok {
		return fmt.Errorf("field WorkflowExecutionID in ChainwriterTargetInputs: required")
	}
	type Plain ChainwriterTargetInputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChainwriterTargetInputs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainwriterTarget) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in ChainwriterTarget: required")
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in ChainwriterTarget: required")
	}
	type Plain ChainwriterTarget
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChainwriterTarget(plain)
	return nil
}
