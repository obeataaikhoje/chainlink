// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: relayer.proto

package loop

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PluginRelayerClient is the client API for PluginRelayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginRelayerClient interface {
	NewRelayer(ctx context.Context, in *NewRelayerRequest, opts ...grpc.CallOption) (*NewRelayerReply, error)
}

type pluginRelayerClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginRelayerClient(cc grpc.ClientConnInterface) PluginRelayerClient {
	return &pluginRelayerClient{cc}
}

func (c *pluginRelayerClient) NewRelayer(ctx context.Context, in *NewRelayerRequest, opts ...grpc.CallOption) (*NewRelayerReply, error) {
	out := new(NewRelayerReply)
	err := c.cc.Invoke(ctx, "/loop.PluginRelayer/NewRelayer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginRelayerServer is the server API for PluginRelayer service.
// All implementations must embed UnimplementedPluginRelayerServer
// for forward compatibility
type PluginRelayerServer interface {
	NewRelayer(context.Context, *NewRelayerRequest) (*NewRelayerReply, error)
	mustEmbedUnimplementedPluginRelayerServer()
}

// UnimplementedPluginRelayerServer must be embedded to have forward compatible implementations.
type UnimplementedPluginRelayerServer struct {
}

func (UnimplementedPluginRelayerServer) NewRelayer(context.Context, *NewRelayerRequest) (*NewRelayerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRelayer not implemented")
}
func (UnimplementedPluginRelayerServer) mustEmbedUnimplementedPluginRelayerServer() {}

// UnsafePluginRelayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginRelayerServer will
// result in compilation errors.
type UnsafePluginRelayerServer interface {
	mustEmbedUnimplementedPluginRelayerServer()
}

func RegisterPluginRelayerServer(s grpc.ServiceRegistrar, srv PluginRelayerServer) {
	s.RegisterService(&PluginRelayer_ServiceDesc, srv)
}

func _PluginRelayer_NewRelayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRelayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginRelayerServer).NewRelayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.PluginRelayer/NewRelayer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginRelayerServer).NewRelayer(ctx, req.(*NewRelayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginRelayer_ServiceDesc is the grpc.ServiceDesc for PluginRelayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginRelayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.PluginRelayer",
	HandlerType: (*PluginRelayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewRelayer",
			Handler:    _PluginRelayer_NewRelayer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// KeystoreClient is the client API for Keystore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeystoreClient interface {
	Accounts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AccountsReply, error)
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignReply, error)
}

type keystoreClient struct {
	cc grpc.ClientConnInterface
}

func NewKeystoreClient(cc grpc.ClientConnInterface) KeystoreClient {
	return &keystoreClient{cc}
}

func (c *keystoreClient) Accounts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AccountsReply, error) {
	out := new(AccountsReply)
	err := c.cc.Invoke(ctx, "/loop.Keystore/Accounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignReply, error) {
	out := new(SignReply)
	err := c.cc.Invoke(ctx, "/loop.Keystore/Sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeystoreServer is the server API for Keystore service.
// All implementations must embed UnimplementedKeystoreServer
// for forward compatibility
type KeystoreServer interface {
	Accounts(context.Context, *empty.Empty) (*AccountsReply, error)
	Sign(context.Context, *SignRequest) (*SignReply, error)
	mustEmbedUnimplementedKeystoreServer()
}

// UnimplementedKeystoreServer must be embedded to have forward compatible implementations.
type UnimplementedKeystoreServer struct {
}

func (UnimplementedKeystoreServer) Accounts(context.Context, *empty.Empty) (*AccountsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Accounts not implemented")
}
func (UnimplementedKeystoreServer) Sign(context.Context, *SignRequest) (*SignReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedKeystoreServer) mustEmbedUnimplementedKeystoreServer() {}

// UnsafeKeystoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeystoreServer will
// result in compilation errors.
type UnsafeKeystoreServer interface {
	mustEmbedUnimplementedKeystoreServer()
}

func RegisterKeystoreServer(s grpc.ServiceRegistrar, srv KeystoreServer) {
	s.RegisterService(&Keystore_ServiceDesc, srv)
}

func _Keystore_Accounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServer).Accounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Keystore/Accounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServer).Accounts(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keystore_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Keystore/Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Keystore_ServiceDesc is the grpc.ServiceDesc for Keystore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Keystore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Keystore",
	HandlerType: (*KeystoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Accounts",
			Handler:    _Keystore_Accounts_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Keystore_Sign_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// RelayerClient is the client API for Relayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RelayerClient interface {
	NewConfigProvider(ctx context.Context, in *NewConfigProviderRequest, opts ...grpc.CallOption) (*NewConfigProviderReply, error)
	NewMedianProvider(ctx context.Context, in *NewMedianProviderRequest, opts ...grpc.CallOption) (*NewMedianProviderReply, error)
	NewMercuryProvider(ctx context.Context, in *NewMercuryProviderRequest, opts ...grpc.CallOption) (*NewMercuryProviderReply, error)
	ChainStatus(ctx context.Context, in *ChainStatusRequest, opts ...grpc.CallOption) (*ChainStatusReply, error)
	ChainStatuses(ctx context.Context, in *ChainStatusesRequest, opts ...grpc.CallOption) (*ChainStatusesReply, error)
	NodeStatuses(ctx context.Context, in *NodeStatusesRequest, opts ...grpc.CallOption) (*NodeStatusesReply, error)
	SendTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type relayerClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayerClient(cc grpc.ClientConnInterface) RelayerClient {
	return &relayerClient{cc}
}

func (c *relayerClient) NewConfigProvider(ctx context.Context, in *NewConfigProviderRequest, opts ...grpc.CallOption) (*NewConfigProviderReply, error) {
	out := new(NewConfigProviderReply)
	err := c.cc.Invoke(ctx, "/loop.Relayer/NewConfigProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) NewMedianProvider(ctx context.Context, in *NewMedianProviderRequest, opts ...grpc.CallOption) (*NewMedianProviderReply, error) {
	out := new(NewMedianProviderReply)
	err := c.cc.Invoke(ctx, "/loop.Relayer/NewMedianProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) NewMercuryProvider(ctx context.Context, in *NewMercuryProviderRequest, opts ...grpc.CallOption) (*NewMercuryProviderReply, error) {
	out := new(NewMercuryProviderReply)
	err := c.cc.Invoke(ctx, "/loop.Relayer/NewMercuryProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) ChainStatus(ctx context.Context, in *ChainStatusRequest, opts ...grpc.CallOption) (*ChainStatusReply, error) {
	out := new(ChainStatusReply)
	err := c.cc.Invoke(ctx, "/loop.Relayer/ChainStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) ChainStatuses(ctx context.Context, in *ChainStatusesRequest, opts ...grpc.CallOption) (*ChainStatusesReply, error) {
	out := new(ChainStatusesReply)
	err := c.cc.Invoke(ctx, "/loop.Relayer/ChainStatuses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) NodeStatuses(ctx context.Context, in *NodeStatusesRequest, opts ...grpc.CallOption) (*NodeStatusesReply, error) {
	out := new(NodeStatusesReply)
	err := c.cc.Invoke(ctx, "/loop.Relayer/NodeStatuses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) SendTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/loop.Relayer/SendTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayerServer is the server API for Relayer service.
// All implementations must embed UnimplementedRelayerServer
// for forward compatibility
type RelayerServer interface {
	NewConfigProvider(context.Context, *NewConfigProviderRequest) (*NewConfigProviderReply, error)
	NewMedianProvider(context.Context, *NewMedianProviderRequest) (*NewMedianProviderReply, error)
	NewMercuryProvider(context.Context, *NewMercuryProviderRequest) (*NewMercuryProviderReply, error)
	ChainStatus(context.Context, *ChainStatusRequest) (*ChainStatusReply, error)
	ChainStatuses(context.Context, *ChainStatusesRequest) (*ChainStatusesReply, error)
	NodeStatuses(context.Context, *NodeStatusesRequest) (*NodeStatusesReply, error)
	SendTx(context.Context, *SendTxRequest) (*empty.Empty, error)
	mustEmbedUnimplementedRelayerServer()
}

// UnimplementedRelayerServer must be embedded to have forward compatible implementations.
type UnimplementedRelayerServer struct {
}

func (UnimplementedRelayerServer) NewConfigProvider(context.Context, *NewConfigProviderRequest) (*NewConfigProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewConfigProvider not implemented")
}
func (UnimplementedRelayerServer) NewMedianProvider(context.Context, *NewMedianProviderRequest) (*NewMedianProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewMedianProvider not implemented")
}
func (UnimplementedRelayerServer) NewMercuryProvider(context.Context, *NewMercuryProviderRequest) (*NewMercuryProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewMercuryProvider not implemented")
}
func (UnimplementedRelayerServer) ChainStatus(context.Context, *ChainStatusRequest) (*ChainStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainStatus not implemented")
}
func (UnimplementedRelayerServer) ChainStatuses(context.Context, *ChainStatusesRequest) (*ChainStatusesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainStatuses not implemented")
}
func (UnimplementedRelayerServer) NodeStatuses(context.Context, *NodeStatusesRequest) (*NodeStatusesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeStatuses not implemented")
}
func (UnimplementedRelayerServer) SendTx(context.Context, *SendTxRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTx not implemented")
}
func (UnimplementedRelayerServer) mustEmbedUnimplementedRelayerServer() {}

// UnsafeRelayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayerServer will
// result in compilation errors.
type UnsafeRelayerServer interface {
	mustEmbedUnimplementedRelayerServer()
}

func RegisterRelayerServer(s grpc.ServiceRegistrar, srv RelayerServer) {
	s.RegisterService(&Relayer_ServiceDesc, srv)
}

func _Relayer_NewConfigProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewConfigProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewConfigProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/NewConfigProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewConfigProvider(ctx, req.(*NewConfigProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_NewMedianProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewMedianProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewMedianProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/NewMedianProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewMedianProvider(ctx, req.(*NewMedianProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_NewMercuryProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewMercuryProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewMercuryProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/NewMercuryProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewMercuryProvider(ctx, req.(*NewMercuryProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_ChainStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).ChainStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/ChainStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).ChainStatus(ctx, req.(*ChainStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_ChainStatuses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainStatusesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).ChainStatuses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/ChainStatuses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).ChainStatuses(ctx, req.(*ChainStatusesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_NodeStatuses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeStatusesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NodeStatuses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/NodeStatuses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NodeStatuses(ctx, req.(*NodeStatusesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_SendTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).SendTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Relayer/SendTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).SendTx(ctx, req.(*SendTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Relayer_ServiceDesc is the grpc.ServiceDesc for Relayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Relayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Relayer",
	HandlerType: (*RelayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewConfigProvider",
			Handler:    _Relayer_NewConfigProvider_Handler,
		},
		{
			MethodName: "NewMedianProvider",
			Handler:    _Relayer_NewMedianProvider_Handler,
		},
		{
			MethodName: "NewMercuryProvider",
			Handler:    _Relayer_NewMercuryProvider_Handler,
		},
		{
			MethodName: "ChainStatus",
			Handler:    _Relayer_ChainStatus_Handler,
		},
		{
			MethodName: "ChainStatuses",
			Handler:    _Relayer_ChainStatuses_Handler,
		},
		{
			MethodName: "NodeStatuses",
			Handler:    _Relayer_NodeStatuses_Handler,
		},
		{
			MethodName: "SendTx",
			Handler:    _Relayer_SendTx_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// DataSourceClient is the client API for DataSource service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataSourceClient interface {
	Observe(ctx context.Context, in *ObserveRequest, opts ...grpc.CallOption) (*ObserveReply, error)
}

type dataSourceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataSourceClient(cc grpc.ClientConnInterface) DataSourceClient {
	return &dataSourceClient{cc}
}

func (c *dataSourceClient) Observe(ctx context.Context, in *ObserveRequest, opts ...grpc.CallOption) (*ObserveReply, error) {
	out := new(ObserveReply)
	err := c.cc.Invoke(ctx, "/loop.DataSource/Observe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataSourceServer is the server API for DataSource service.
// All implementations must embed UnimplementedDataSourceServer
// for forward compatibility
type DataSourceServer interface {
	Observe(context.Context, *ObserveRequest) (*ObserveReply, error)
	mustEmbedUnimplementedDataSourceServer()
}

// UnimplementedDataSourceServer must be embedded to have forward compatible implementations.
type UnimplementedDataSourceServer struct {
}

func (UnimplementedDataSourceServer) Observe(context.Context, *ObserveRequest) (*ObserveReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Observe not implemented")
}
func (UnimplementedDataSourceServer) mustEmbedUnimplementedDataSourceServer() {}

// UnsafeDataSourceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataSourceServer will
// result in compilation errors.
type UnsafeDataSourceServer interface {
	mustEmbedUnimplementedDataSourceServer()
}

func RegisterDataSourceServer(s grpc.ServiceRegistrar, srv DataSourceServer) {
	s.RegisterService(&DataSource_ServiceDesc, srv)
}

func _DataSource_Observe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObserveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceServer).Observe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.DataSource/Observe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceServer).Observe(ctx, req.(*ObserveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataSource_ServiceDesc is the grpc.ServiceDesc for DataSource service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataSource_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.DataSource",
	HandlerType: (*DataSourceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Observe",
			Handler:    _DataSource_Observe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// OffchainConfigDigesterClient is the client API for OffchainConfigDigester service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OffchainConfigDigesterClient interface {
	ConfigDigest(ctx context.Context, in *ConfigDigestRequest, opts ...grpc.CallOption) (*ConfigDigestReply, error)
	ConfigDigestPrefix(ctx context.Context, in *ConfigDigestPrefixRequest, opts ...grpc.CallOption) (*ConfigDigestPrefixReply, error)
}

type offchainConfigDigesterClient struct {
	cc grpc.ClientConnInterface
}

func NewOffchainConfigDigesterClient(cc grpc.ClientConnInterface) OffchainConfigDigesterClient {
	return &offchainConfigDigesterClient{cc}
}

func (c *offchainConfigDigesterClient) ConfigDigest(ctx context.Context, in *ConfigDigestRequest, opts ...grpc.CallOption) (*ConfigDigestReply, error) {
	out := new(ConfigDigestReply)
	err := c.cc.Invoke(ctx, "/loop.OffchainConfigDigester/ConfigDigest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offchainConfigDigesterClient) ConfigDigestPrefix(ctx context.Context, in *ConfigDigestPrefixRequest, opts ...grpc.CallOption) (*ConfigDigestPrefixReply, error) {
	out := new(ConfigDigestPrefixReply)
	err := c.cc.Invoke(ctx, "/loop.OffchainConfigDigester/ConfigDigestPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OffchainConfigDigesterServer is the server API for OffchainConfigDigester service.
// All implementations must embed UnimplementedOffchainConfigDigesterServer
// for forward compatibility
type OffchainConfigDigesterServer interface {
	ConfigDigest(context.Context, *ConfigDigestRequest) (*ConfigDigestReply, error)
	ConfigDigestPrefix(context.Context, *ConfigDigestPrefixRequest) (*ConfigDigestPrefixReply, error)
	mustEmbedUnimplementedOffchainConfigDigesterServer()
}

// UnimplementedOffchainConfigDigesterServer must be embedded to have forward compatible implementations.
type UnimplementedOffchainConfigDigesterServer struct {
}

func (UnimplementedOffchainConfigDigesterServer) ConfigDigest(context.Context, *ConfigDigestRequest) (*ConfigDigestReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigDigest not implemented")
}
func (UnimplementedOffchainConfigDigesterServer) ConfigDigestPrefix(context.Context, *ConfigDigestPrefixRequest) (*ConfigDigestPrefixReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigDigestPrefix not implemented")
}
func (UnimplementedOffchainConfigDigesterServer) mustEmbedUnimplementedOffchainConfigDigesterServer() {
}

// UnsafeOffchainConfigDigesterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OffchainConfigDigesterServer will
// result in compilation errors.
type UnsafeOffchainConfigDigesterServer interface {
	mustEmbedUnimplementedOffchainConfigDigesterServer()
}

func RegisterOffchainConfigDigesterServer(s grpc.ServiceRegistrar, srv OffchainConfigDigesterServer) {
	s.RegisterService(&OffchainConfigDigester_ServiceDesc, srv)
}

func _OffchainConfigDigester_ConfigDigest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigDigestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffchainConfigDigesterServer).ConfigDigest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.OffchainConfigDigester/ConfigDigest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffchainConfigDigesterServer).ConfigDigest(ctx, req.(*ConfigDigestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OffchainConfigDigester_ConfigDigestPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigDigestPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffchainConfigDigesterServer).ConfigDigestPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.OffchainConfigDigester/ConfigDigestPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffchainConfigDigesterServer).ConfigDigestPrefix(ctx, req.(*ConfigDigestPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OffchainConfigDigester_ServiceDesc is the grpc.ServiceDesc for OffchainConfigDigester service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OffchainConfigDigester_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.OffchainConfigDigester",
	HandlerType: (*OffchainConfigDigesterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigDigest",
			Handler:    _OffchainConfigDigester_ConfigDigest_Handler,
		},
		{
			MethodName: "ConfigDigestPrefix",
			Handler:    _OffchainConfigDigester_ConfigDigestPrefix_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// ContractConfigTrackerClient is the client API for ContractConfigTracker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractConfigTrackerClient interface {
	LatestConfigDetails(ctx context.Context, in *LatestConfigDetailsRequest, opts ...grpc.CallOption) (*LatestConfigDetailsReply, error)
	LatestConfig(ctx context.Context, in *LatestConfigRequest, opts ...grpc.CallOption) (*LatestConfigReply, error)
	LatestBlockHeight(ctx context.Context, in *LatestBlockHeightRequest, opts ...grpc.CallOption) (*LatestBlockHeightReply, error)
}

type contractConfigTrackerClient struct {
	cc grpc.ClientConnInterface
}

func NewContractConfigTrackerClient(cc grpc.ClientConnInterface) ContractConfigTrackerClient {
	return &contractConfigTrackerClient{cc}
}

func (c *contractConfigTrackerClient) LatestConfigDetails(ctx context.Context, in *LatestConfigDetailsRequest, opts ...grpc.CallOption) (*LatestConfigDetailsReply, error) {
	out := new(LatestConfigDetailsReply)
	err := c.cc.Invoke(ctx, "/loop.ContractConfigTracker/LatestConfigDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractConfigTrackerClient) LatestConfig(ctx context.Context, in *LatestConfigRequest, opts ...grpc.CallOption) (*LatestConfigReply, error) {
	out := new(LatestConfigReply)
	err := c.cc.Invoke(ctx, "/loop.ContractConfigTracker/LatestConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractConfigTrackerClient) LatestBlockHeight(ctx context.Context, in *LatestBlockHeightRequest, opts ...grpc.CallOption) (*LatestBlockHeightReply, error) {
	out := new(LatestBlockHeightReply)
	err := c.cc.Invoke(ctx, "/loop.ContractConfigTracker/LatestBlockHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContractConfigTrackerServer is the server API for ContractConfigTracker service.
// All implementations must embed UnimplementedContractConfigTrackerServer
// for forward compatibility
type ContractConfigTrackerServer interface {
	LatestConfigDetails(context.Context, *LatestConfigDetailsRequest) (*LatestConfigDetailsReply, error)
	LatestConfig(context.Context, *LatestConfigRequest) (*LatestConfigReply, error)
	LatestBlockHeight(context.Context, *LatestBlockHeightRequest) (*LatestBlockHeightReply, error)
	mustEmbedUnimplementedContractConfigTrackerServer()
}

// UnimplementedContractConfigTrackerServer must be embedded to have forward compatible implementations.
type UnimplementedContractConfigTrackerServer struct {
}

func (UnimplementedContractConfigTrackerServer) LatestConfigDetails(context.Context, *LatestConfigDetailsRequest) (*LatestConfigDetailsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestConfigDetails not implemented")
}
func (UnimplementedContractConfigTrackerServer) LatestConfig(context.Context, *LatestConfigRequest) (*LatestConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestConfig not implemented")
}
func (UnimplementedContractConfigTrackerServer) LatestBlockHeight(context.Context, *LatestBlockHeightRequest) (*LatestBlockHeightReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestBlockHeight not implemented")
}
func (UnimplementedContractConfigTrackerServer) mustEmbedUnimplementedContractConfigTrackerServer() {}

// UnsafeContractConfigTrackerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractConfigTrackerServer will
// result in compilation errors.
type UnsafeContractConfigTrackerServer interface {
	mustEmbedUnimplementedContractConfigTrackerServer()
}

func RegisterContractConfigTrackerServer(s grpc.ServiceRegistrar, srv ContractConfigTrackerServer) {
	s.RegisterService(&ContractConfigTracker_ServiceDesc, srv)
}

func _ContractConfigTracker_LatestConfigDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestConfigDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractConfigTrackerServer).LatestConfigDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.ContractConfigTracker/LatestConfigDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractConfigTrackerServer).LatestConfigDetails(ctx, req.(*LatestConfigDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractConfigTracker_LatestConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractConfigTrackerServer).LatestConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.ContractConfigTracker/LatestConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractConfigTrackerServer).LatestConfig(ctx, req.(*LatestConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractConfigTracker_LatestBlockHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestBlockHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractConfigTrackerServer).LatestBlockHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.ContractConfigTracker/LatestBlockHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractConfigTrackerServer).LatestBlockHeight(ctx, req.(*LatestBlockHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContractConfigTracker_ServiceDesc is the grpc.ServiceDesc for ContractConfigTracker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContractConfigTracker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.ContractConfigTracker",
	HandlerType: (*ContractConfigTrackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LatestConfigDetails",
			Handler:    _ContractConfigTracker_LatestConfigDetails_Handler,
		},
		{
			MethodName: "LatestConfig",
			Handler:    _ContractConfigTracker_LatestConfig_Handler,
		},
		{
			MethodName: "LatestBlockHeight",
			Handler:    _ContractConfigTracker_LatestBlockHeight_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// ContractTransmitterClient is the client API for ContractTransmitter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractTransmitterClient interface {
	Transmit(ctx context.Context, in *TransmitRequest, opts ...grpc.CallOption) (*TransmitReply, error)
	LatestConfigDigestAndEpoch(ctx context.Context, in *LatestConfigDigestAndEpochRequest, opts ...grpc.CallOption) (*LatestConfigDigestAndEpochReply, error)
	FromAccount(ctx context.Context, in *FromAccountRequest, opts ...grpc.CallOption) (*FromAccountReply, error)
}

type contractTransmitterClient struct {
	cc grpc.ClientConnInterface
}

func NewContractTransmitterClient(cc grpc.ClientConnInterface) ContractTransmitterClient {
	return &contractTransmitterClient{cc}
}

func (c *contractTransmitterClient) Transmit(ctx context.Context, in *TransmitRequest, opts ...grpc.CallOption) (*TransmitReply, error) {
	out := new(TransmitReply)
	err := c.cc.Invoke(ctx, "/loop.ContractTransmitter/Transmit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractTransmitterClient) LatestConfigDigestAndEpoch(ctx context.Context, in *LatestConfigDigestAndEpochRequest, opts ...grpc.CallOption) (*LatestConfigDigestAndEpochReply, error) {
	out := new(LatestConfigDigestAndEpochReply)
	err := c.cc.Invoke(ctx, "/loop.ContractTransmitter/LatestConfigDigestAndEpoch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractTransmitterClient) FromAccount(ctx context.Context, in *FromAccountRequest, opts ...grpc.CallOption) (*FromAccountReply, error) {
	out := new(FromAccountReply)
	err := c.cc.Invoke(ctx, "/loop.ContractTransmitter/FromAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContractTransmitterServer is the server API for ContractTransmitter service.
// All implementations must embed UnimplementedContractTransmitterServer
// for forward compatibility
type ContractTransmitterServer interface {
	Transmit(context.Context, *TransmitRequest) (*TransmitReply, error)
	LatestConfigDigestAndEpoch(context.Context, *LatestConfigDigestAndEpochRequest) (*LatestConfigDigestAndEpochReply, error)
	FromAccount(context.Context, *FromAccountRequest) (*FromAccountReply, error)
	mustEmbedUnimplementedContractTransmitterServer()
}

// UnimplementedContractTransmitterServer must be embedded to have forward compatible implementations.
type UnimplementedContractTransmitterServer struct {
}

func (UnimplementedContractTransmitterServer) Transmit(context.Context, *TransmitRequest) (*TransmitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transmit not implemented")
}
func (UnimplementedContractTransmitterServer) LatestConfigDigestAndEpoch(context.Context, *LatestConfigDigestAndEpochRequest) (*LatestConfigDigestAndEpochReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestConfigDigestAndEpoch not implemented")
}
func (UnimplementedContractTransmitterServer) FromAccount(context.Context, *FromAccountRequest) (*FromAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FromAccount not implemented")
}
func (UnimplementedContractTransmitterServer) mustEmbedUnimplementedContractTransmitterServer() {}

// UnsafeContractTransmitterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractTransmitterServer will
// result in compilation errors.
type UnsafeContractTransmitterServer interface {
	mustEmbedUnimplementedContractTransmitterServer()
}

func RegisterContractTransmitterServer(s grpc.ServiceRegistrar, srv ContractTransmitterServer) {
	s.RegisterService(&ContractTransmitter_ServiceDesc, srv)
}

func _ContractTransmitter_Transmit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractTransmitterServer).Transmit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.ContractTransmitter/Transmit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractTransmitterServer).Transmit(ctx, req.(*TransmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractTransmitter_LatestConfigDigestAndEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestConfigDigestAndEpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractTransmitterServer).LatestConfigDigestAndEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.ContractTransmitter/LatestConfigDigestAndEpoch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractTransmitterServer).LatestConfigDigestAndEpoch(ctx, req.(*LatestConfigDigestAndEpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractTransmitter_FromAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FromAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractTransmitterServer).FromAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.ContractTransmitter/FromAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractTransmitterServer).FromAccount(ctx, req.(*FromAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContractTransmitter_ServiceDesc is the grpc.ServiceDesc for ContractTransmitter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContractTransmitter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.ContractTransmitter",
	HandlerType: (*ContractTransmitterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Transmit",
			Handler:    _ContractTransmitter_Transmit_Handler,
		},
		{
			MethodName: "LatestConfigDigestAndEpoch",
			Handler:    _ContractTransmitter_LatestConfigDigestAndEpoch_Handler,
		},
		{
			MethodName: "FromAccount",
			Handler:    _ContractTransmitter_FromAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

// ServiceClient is the client API for Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceClient interface {
	Start(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Name(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NameReply, error)
	Close(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Ready(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Healthy(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	HealthReport(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HealthReportReply, error)
}

type serviceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceClient(cc grpc.ClientConnInterface) ServiceClient {
	return &serviceClient{cc}
}

func (c *serviceClient) Start(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/loop.Service/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Name(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NameReply, error) {
	out := new(NameReply)
	err := c.cc.Invoke(ctx, "/loop.Service/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Close(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/loop.Service/Close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Ready(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/loop.Service/Ready", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Healthy(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/loop.Service/Healthy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) HealthReport(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HealthReportReply, error) {
	out := new(HealthReportReply)
	err := c.cc.Invoke(ctx, "/loop.Service/HealthReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceServer is the server API for Service service.
// All implementations must embed UnimplementedServiceServer
// for forward compatibility
type ServiceServer interface {
	Start(context.Context, *empty.Empty) (*empty.Empty, error)
	Name(context.Context, *empty.Empty) (*NameReply, error)
	Close(context.Context, *empty.Empty) (*empty.Empty, error)
	Ready(context.Context, *empty.Empty) (*empty.Empty, error)
	Healthy(context.Context, *empty.Empty) (*empty.Empty, error)
	HealthReport(context.Context, *empty.Empty) (*HealthReportReply, error)
	mustEmbedUnimplementedServiceServer()
}

// UnimplementedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceServer struct {
}

func (UnimplementedServiceServer) Start(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedServiceServer) Name(context.Context, *empty.Empty) (*NameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedServiceServer) Close(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedServiceServer) Ready(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedServiceServer) Healthy(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Healthy not implemented")
}
func (UnimplementedServiceServer) HealthReport(context.Context, *empty.Empty) (*HealthReportReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthReport not implemented")
}
func (UnimplementedServiceServer) mustEmbedUnimplementedServiceServer() {}

// UnsafeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServer will
// result in compilation errors.
type UnsafeServiceServer interface {
	mustEmbedUnimplementedServiceServer()
}

func RegisterServiceServer(s grpc.ServiceRegistrar, srv ServiceServer) {
	s.RegisterService(&Service_ServiceDesc, srv)
}

func _Service_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Service/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Start(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Service/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Name(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Service/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Close(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Service/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Ready(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Healthy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Healthy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Service/Healthy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Healthy(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_HealthReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).HealthReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/loop.Service/HealthReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).HealthReport(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Service_ServiceDesc is the grpc.ServiceDesc for Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Service_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Service",
	HandlerType: (*ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _Service_Start_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _Service_Name_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _Service_Close_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _Service_Ready_Handler,
		},
		{
			MethodName: "Healthy",
			Handler:    _Service_Healthy_Handler,
		},
		{
			MethodName: "HealthReport",
			Handler:    _Service_HealthReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}
